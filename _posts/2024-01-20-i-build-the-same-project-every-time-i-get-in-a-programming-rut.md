---
layout: post
title: I Build The Same Project Every Time I Get In A Programming Rut
date: '2024-01-20 21:47:33 +0000'
categories: [Blog]
tags: [chess, programming]
---

I'll admit it: my original ideas are really rather boring.

I think it's fair to say that in the computer programming world, everybody gets into a niche. Some people prefer building with a specific framework or platform, others like the challenge of building "Hello World" apps in different languages, whereas other prefer solving a specific kind of problem. I fall into this last camp.

Left to my own devices, I will try to solve the <a target="_blank" href="https://en.wikipedia.org/wiki/Knight's_tour">knight's tour problem</a> <a target="_blank" href="https://github.com/OulipianSummer/Perecian">over</a>, and <a target="_blank" href="https://www.andrew-benbow.com/posts/joust" >over</a>, and <a target="_blank" href="https://github.com/OulipianSummer/rudrata">over</a> again. The exact implementation details differ slightly depending on what I'm learning at the time, but the core idea remains: *how do you get this little horsey guy around the chessboard real quick?*

The usual rhythym is that my professional work starts wearing on me, I look for ways to enhance my skillset or work on something personally fulfilling, I get an idea about how I can work with knight's tours in some novel way, and I find myself gravitating towards documentation for tools and frameworks that will help me build the app I want to make. And, unsurprisingly, I've just started building yet <a target="_blank" href="https://github.com/OulipianSummer/perec">another project</a> involving this ancient chess puzzle in my spare time, during lunch breaks, and over the weekends.

Sometimes it feels like I'm still just solving the same problem, unable to move on from it because I just found yet another interesting way I can make it more accessible, more complete, or more interesting to an outside observer. It's probably not a shock that my first real bit of independent programming featured knight's tours.

Over time I think I've finally hit on why this obsession with an algorithm has resulted in so many similar projects. Ultimately, I want to create something that fits one or all of these criteria: I want people to use and enjoy the things I make; I want to create something that takes a complex problem and make the solution look simple; and, of course, I want to make something that makes me feel satisfied as a developer.

Admittedly, there is something reassuring about starting out in familiar space before exploring uncharted territory. The business logic practically writes itself and you get to just focus on learning the things you don't know. You've already solved the corner cases, know how to avoid common hangups, and you probably have snippets of code you can reuse to navigate the trickier logic.

In short: you can ensure sure you're only making this thing for fun. Once you hit a stopping place, you can close the lid of your laptop, and get on with your life without loosing sleep over the fine details or imaginary optimizations that you should make for when your project suddenly gets over 1,000 stars on GitHub overnight.

Of course, that also means I'm a mood developer: I'm only working on my personal projects when I feel like it, even if they end up just getting tossed into the scrap heap. But that can be freeing too. Otherwise, the creeping shame of yet another unfinished personal proejct I had high hopes for would be pretty heavy, and I might just try to force myself wrap it up out of guilt.

In today's programming space, it feels like there is a lot of pressure on trying to come up with new and revolutionary ideas or planning out your entire server-less infrastructure empire before you even open a new repo. Instead, I think there is something positively delightful to be said for being boring and having the same boring ideas: it frees you to solve the problems that matter to you, even if it's really just the same problem you always try to solve.
